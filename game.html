<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Making your first game, part 1</title>
	<script type="text/javascript" src="bower_components/phaser/build/phaser.min.js"></script>
    <script type="text/javascript" src="bower_components/numjs/dist/numjs.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
    var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', { preload: preload, create: create, update: update });

    function preload() {
        game.load.image('pineapple', 'pineapple.png')
        game.load.image('background', 'water_tile.jpg');
        game.load.spritesheet('pineappleAnimation', 'pineappleAnimation.png',165,465);
    }

    var player;
    function create() {
        NUM_ENEMIES = 30;

        // World size
        game.world.setBounds(0, 0, 4000, 3000);

        //cursor keys
        cursors = game.input.keyboard.createCursorKeys()

        //  We're going to be using physics, so enable the Arcade Physics system
        game.physics.startSystem(Phaser.Physics.ARCADE);

        // Enemy group
        EnemyGroup = game.add.group();

        // Bullet group
        BulletGroup = game.add.group();

        // EnemyManager class
        class EnemyManager {
            constructor() {
                this.enemies = []

                // Evolution hyperparams
                this.EV_SIGMA = 0.01;

                // Reward stats
                this.max_r = 0.0;
                this.avg_r = 0.0;

                // Id management
                this.curr_id = 0;
            }

            addEnemy(e) {
                this.enemies.push(e);
                EnemyGroup.add(e.sprite);
                e.id = this.curr_id;
                this.curr_id += 1;
            }

            next() {
                for (var i in this.enemies) {       
                    this.enemies[i].next({ 'distances': this.getDistances(this.enemies[i].sprite.x, this.enemies[i].sprite.y) })
                }
            }

            getDistances(x, y) {
                var dists = []
                var a = [x, y]
                for (var i in this.enemies) {
                    var b = [this.enemies[i].sprite.x, this.enemies[i].sprite.y]
                    var dist = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2))
                    dists.push([dist, this.enemies[i]])                    
                }
                return dists
            }

            getBestEnemy() {
                var accum = 0.0;
                var be = this.enemies[0];
                var br = be.reward;
                for (var i in this.enemies) {
                    accum += this.enemies[i].reward;
                    if (this.enemies[i].reward > br) {
                        br = this.enemies[i].reward;
                        be = this.enemies[i]
                    }
                }
                this.avg_r = accum / this.enemies.length;
                this.max_r = br;
                return be;
            }

            removeDeadEnemies() {
                this.enemies = this.enemies.filter(function(a) { return a.sprite.alive; })
                this.enemies = this.enemies.slice(0, NUM_ENEMIES)
            }

            evolveNewEnemy(e_old) {
                var e = new Enemy(e_old);
                var be = this.getBestEnemy()
                var w_1 = be.w_1.add(nj.random([10,5]).subtract(nj.ones([10,5]).divide(2.0)).multiply(this.EV_SIGMA))
                var w_2 = be.w_2.add(nj.random([5,5]).subtract(nj.ones([5,5]).divide(2.0)).multiply(this.EV_SIGMA))
                var w_out = be.w_out.add(nj.random([5,4]).subtract(nj.ones([5,4]).divide(2.0)).multiply(this.EV_SIGMA))
                var b_1 = be.b_1.add(nj.random([5]).subtract(nj.ones([5]).divide(2.0)).multiply(this.EV_SIGMA))
                var b_2 = be.b_2.add(nj.random([5]).subtract(nj.ones([5]).divide(2.0)).multiply(this.EV_SIGMA))
                var b_out = be.b_out.add(nj.random([4]).subtract(nj.ones([4]).divide(2.0)).multiply(this.EV_SIGMA))
                e.set_params(w_1, w_2, w_out, b_1, b_2, b_out)
                this.addEnemy(e)
            }
        }
       
        class Player {
            constructor(xPos,yPos,scale,image) {
                this.sprite = game.add.sprite(xPos,yPos,image);
                game.physics.arcade.enable(this.sprite);
                this.sprite.scale.setTo(scale,scale);
                game.add.tween(this.sprite.scale).to( {x:scale*1.4, y:scale*1.4}, 4000, Phaser.Easing.Linear.None,true, 0, 200, true);
                game.camera.follow(this.sprite);


                this.shadow = game.add.sprite(xPos + this.offset.x, yPos + this.offset.y, image);
                game.physics.arcade.enable(this.shadow)
                this.shadow.scale.setTo(scale, scale)
                game.add.tween(this.sprite.scale).to( {x:scale * 1.4, y:scale * 1.4}, 4000, Phaser.Easing.Linear.Non, true, 0, 200, true);
                this.shadow.tint = 0x000000;
                this.shadow.alpha = 0.6;
                game.world.moveDown(this.shadow)
            }

            addAnimation (name) {
                this.sprite.animations.add(name);
                this.shadow.animations.add(name);
            }

            playAnimation (name, framesPSecond, loop) {
                this.sprite.animations.play(name,framesPSecond,loop);
                this.shadow.animations.play(name, framesPSecond, loop);
            }
            //controls player movement- parameter is milliseconds until the image gets to the cursor
            movement(secondsToContact) {
                
                this.sprite.velocity = game.physics.arcade.moveToPointer(this.sprite, 50, game.input.activePointer, secondsToContact);
                this.sprite.rotation = game.physics.arcade.angleToPointer(this.sprite) + (Math.PI/2);
                this.shadow.velocity = game.physics.arcade.moveToPointer(this.shadow, 50, game.input.activePointer, secondsToContact);
                this.shadow.rotation = game.physics.arcade.angleToPointer(this.shadow) + (Math.PI/2);
            }

        }

        function EnemySprite(width, height, color, x, y, a) {
                // Create sprite
                var sprite;
                var bmd = game.add.bitmapData(width, height);
                 
                bmd.ctx.beginPath();
                bmd.ctx.rect(0, 0, width, height);
                bmd.ctx.fillStyle = color;
                bmd.ctx.fill();
                sprite = game.add.sprite(x, y, bmd);
                game.physics.arcade.enable(sprite)
                sprite.anchor.setTo(0, 0.5);

                // Rotated to init angle
                sprite.angle = a

                // Bounding box
                sprite.body.setSize(width*2, width*2, -1.0 * width, -1.0 * width);
                return sprite;
        }
    
        class Enemy {
            constructor(e_old) {
                // Sprite
                if (e_old == null) {
                    this.sprite = EnemySprite(32, 16, '#ffffff', Math.random() * game.world.width, Math.random() * game.world.height, Math.random() * 360);
                }
                else {
                    this.sprite = e_old;
                    this.sprite.reset(Math.random() * game.world.width, Math.random() * game.world.height);
                    this.sprite.alive = true;
                }

                // ID
                this.id = null;

                // Movement hyperparams
                this.movement_weights = [3, 100, 100];

                // Policy params
                this.w_1 = nj.random([10,5]).subtract(nj.ones([10,5]).divide(2.0))
                this.w_2 = nj.random([5,5]).subtract(nj.ones([5,5]).divide(2.0))
                this.w_out = nj.random([5,4]).subtract(nj.ones([5,4]).divide(2.0))
                this.b_1 = nj.zeros([5])
                this.b_2 = nj.zeros([5])
                this.b_out = nj.zeros([4])
                //this.b_1 = nj.random([5])
                //this.b_2 = nj.random([5])
                //this.b_out = nj.random([3])

                // Enemy hyperparams
                this.MAX_SPEED = 200;
                this.MAX_ANGULAR = 250;
                this.SURVIVAL_REWARD = 0.01;
                this.KILL_ENEMY_REWARD = 15.0;
                this.DRAG = 2.0;

                // Reward counter
                this.reward = 0.0

                // Bullet regularizer
                this.FRAMES_REQUIRED_FOR_SHOT = 30;
                this.frames_since_last_shot = Math.random() * this.FRAMES_REQUIRED_FOR_SHOT;
            }

            set_params(w_1, w_2, w_out, b_1, b_2, b_out) {
                this.w_1 = w_1
                this.w_2 = w_2
                this.w_out = w_out
                this.b_1 = b_1
                this.b_2 = b_2
                this.b_out = b_out
            }

            // Actuators
            thrust_forward(a) {
                var vfa = game.physics.arcade.velocityFromAngle(this.sprite.angle, a); 
                this.sprite.body.velocity.x += vfa.x
                this.sprite.body.velocity.y += vfa.y
            }

            thrust_left(a) {
                this.sprite.body.angularVelocity -= ((a + 1.0) / 2.0);
                if (this.sprite.body.angularVelocity < (-1.0 * this.MAX_ANGULAR)) { this.sprite.body.angularVelocity = -1.0 * this.MAX_ANGULAR; }
            }

            thrust_right(a) {
                this.sprite.body.angularVelocity += (a + 1.0)/2.0;
                if (this.sprite.body.angularVelocity > this.MAX_ANGULAR) { this.sprite.body.angularVelocity = this.MAX_ANGULAR; }
            }

            fire() {
                if (this.frames_since_last_shot > this.FRAMES_REQUIRED_FOR_SHOT) {
                    var vfa = game.physics.arcade.velocityFromAngle(this.sprite.angle, 8);
                    var b = new Bullet(this.sprite.x - vfa.x, this.sprite.y - vfa.y, 180 + this.sprite.angle);
                    b.sprite.__owner_id__ = this.id;
                    BulletGroup.add(b.sprite);
                    this.frames_since_last_shot = 0.0;
                    this.FRAMES_REQUIRED_FOR_SHOT = (Math.random() * 10) + 30;
                }
            }
    
            nonlin(x) {
                for (var i = 0; i < x.shape[0]; i++) {
                    x.set(i, Math.max(0, x.get(i)))
                }
                return x;
            }

            ff(i) {
                var h_1 = nj.sigmoid(i.dot(this.w_1).add(this.b_1))
                var h_2 = nj.sigmoid(h_1.dot(this.w_2).add(this.b_2))
                return nj.sigmoid(h_2.dot(this.w_out).add(this.b_out))
            }

            next(args) {
                // increment reward
                this.reward += this.SURVIVAL_REWARD;

                var dists = args['distances']
                dists.sort(function(a, b) { return a[0] - b[0] })
                var top_3 = dists.slice(1, 4);
                
                var mx = this.sprite.x
                var my = this.sprite.y
                if (top_3.length >= 3) {
                    var i = nj.array([ mx - top_3[0][1].sprite.x, my - top_3[0][1].sprite.y, mx - top_3[1][1].sprite.x, my - top_3[1][1].sprite.y, mx - top_3[2][1].sprite.x, my - top_3[2][1].sprite.y, 0.0, 0.0, 0.0, 0.0])
                }
                else {
                    var i = nj.zeros([10])
                }
                var out = this.ff(i)

                this.thrust_forward(out.get(0) * this.movement_weights[0])
                this.thrust_left(out.get(1) * this.movement_weights[1])
                this.thrust_right(out.get(2) * this.movement_weights[2])
                if (out.get(3) > 0.5) { this.fire(); }

                // World wrap
                game.world.wrap(this.sprite, 5.0, false,  true, true)

                // Mav vel
                this.sprite.body.velocity.setMagnitude(Math.min(this.MAX_SPEED, this.sprite.body.velocity.getMagnitude()));

                // No skate
                //this.sprite.angle = Math.atan2(this.sprite.body.velocity.y, this.sprite.body.velocity.x) * (180.0 / Math.PI)

                // Drag
                var vfa = game.physics.arcade.velocityFromAngle(this.sprite.angle, this.DRAG);
                this.sprite.body.velocity.x -= vfa.x;
                this.sprite.body.velocity.y -= vfa.y;
                if (this.sprite.body.angularVelocity > 0) { this.sprite.body.angularVelocity -= this.DRAG; }
                else if (this.sprite.body.angularVelocity < 0) { this.sprite.body.angularVelocity += this.DRAG;}

                // Bullet management
                this.frames_since_last_shot += 1;
            }
            
        }

        class Bullet {
            constructor(x, y, a) {
                // bullet v
                this.V = 600.0;

                this.bmd = game.add.bitmapData(8, 4);
                 
                this.bmd.ctx.beginPath();
                this.bmd.ctx.rect(0, 0, 8, 4);
                this.bmd.ctx.fillStyle = '#ff0000';
                this.bmd.ctx.fill();
                this.sprite = game.add.sprite(x, y, this.bmd);
                game.physics.arcade.enable(this.sprite)
                //this.sprite.anchor.setTo(1.0, 0.5);

                // Rotated to init angle
                this.sprite.angle = a

                // Give bullet velocity
                var vfa = game.physics.arcade.velocityFromAngle(this.sprite.angle, this.V);
                this.sprite.body.velocity.x = vfa.x;
                this.sprite.body.velocity.y = vfa.y;
            }
        }

        //create the background
        tileSprite = game.add.tileSprite(0, 0, window.innerWidth*10, window.innerHeight*10, 'background');
        tileSprite.scale.setTo(0.75, 0.75);
        game.world.sendToBack(tileSprite)

        EM = new EnemyManager();
        for (var i = 0; i < NUM_ENEMIES; i++) {
            var e = new Enemy(null);
            EM.addEnemy(e)
        }

        //create a new player
        player = new Player(window.centerX, window.centerY, 0.15, 'pineappleAnimation');

        //add player animation
        player.addAnimation('pineappleAnimation');
    }

    function update() {
        EM.next()

        //plays animation
        player.playAnimation('pineappleAnimation', 5, true);
        //controls how fast pineapple moves towards mouse
        player.movement(500);


        console.log(EM.avg_r, EM.max_r);

        // DEBUGGING HIT BOX
        /*
        for (var i in EM.enemies) {
            game.debug.body(EM.enemies[i].sprite);
        }
        */

        function enemyCollisionHandler(e1, e2) {
            e1.kill()
            e2.kill()
            EM.evolveNewEnemy(e1)
            EM.evolveNewEnemy(e2)
        }

        function bulletCollisionHandler(a1, a2) {
            a1.kill()
            EM.evolveNewEnemy(a1);
            for (var i in EM.enemies) {
                if (EM.enemies[i].id == a2.__owner_id__) { EM.enemies[i].reward += EM.enemies[i].KILL_ENEMY_REWARD; }
            }
            a2.destroy()
        }

        // Enemy collisions
        // game.physics.arcade.collide(EnemyGroup, EnemyGroup, null, enemyCollisionHandler);
        EM.removeDeadEnemies()

        // Bullet x Enemy collisions
        game.physics.arcade.collide(EnemyGroup, BulletGroup, bulletCollisionHandler);

        // Kill off screen bullets
        for (var i in BulletGroup.children) {
            var bx = BulletGroup.children[i].x
            var by = BulletGroup.children[i].y
            if (bx < game.camera.x || bx > game.camera.x + game.camera.width || by < game.camera.y || by > game.camera.y + game.camera.height) {
                BulletGroup.children[i].destroy();
            }
        }
    }

</script>

</body>
</html>
