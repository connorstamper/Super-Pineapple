<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Making your first game, part 1</title>
	<script type="text/javascript" src="bower_components/phaser/build/phaser.min.js"></script>
    <script type="text/javascript" src="bower_components/numjs/dist/numjs.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
    var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', { preload: preload, create: create, update: update });

    function preload() {
        /*
        game.load.image('sky', 'assets/sky.png');
        game.load.image('ground', 'assets/platform.png');
        game.load.image('star', 'assets/star.png');
        game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
        */
    }

    function create() {
        // World size
        game.world.setBounds(0, 0, 2000, 1000);
        

        cursors = game.input.keyboard.createCursorKeys()

        //  We're going to be using physics, so enable the Arcade Physics system
        game.physics.startSystem(Phaser.Physics.ARCADE);

        // EnemyManager class
        class EnemyManager {
            constructor() {
                this.enemies = []
                this.player
            }

            addEnemy(e) {
                this.enemies.push(e)
            }

            next() {
                for (var i in this.enemies) {       
                    this.enemies[i].next({ 'distances': this.getDistances(this.enemies[i].sprite.x, this.enemies[i].sprite.y) })
                }
            }

            getDistances(x, y) {
                var dists = []
                var a = [x, y]
                for (var i in this.enemies) {
                    var b = [this.enemies[i].sprite.x, this.enemies[i].sprite.y]
                    var dist = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2))
                    dists.push([dist, this.enemies[i]])                    
                }
                return dists
            }
        }

        // Enemy class
        class Enemy {
            constructor(width, height, color, x, y, a) {
                this.sprite;
                this.bmd = game.add.bitmapData(width, height);
                 
                this.bmd.ctx.beginPath();
                this.bmd.ctx.rect(0, 0, width, height);
                this.bmd.ctx.fillStyle = color;
                this.bmd.ctx.fill();
                this.sprite = game.add.sprite(x, y, this.bmd);
                game.physics.arcade.enable(this.sprite)
                this.sprite.anchor.setTo(1.0, 0.5);

                this.sprite.angle = a

                // Movement mechanics
                this.sprite.drag = 10000;
                this.movement_weights = [3, 100, 100];

                // Policy params
                this.w_1 = nj.random([10,5]).subtract(nj.ones([10,5]).divide(2.0))
                this.w_2 = nj.random([5,5]).subtract(nj.ones([5,5]).divide(2.0))
                this.w_out = nj.random([5,3]).subtract(nj.ones([5,3]).divide(2.0))
                this.b_1 = nj.random([5])
                this.b_2 = nj.random([5])
                this.b_out = nj.random([3])

                this.MAX_SPEED = 200;
                this.MAX_ANGULAR = 250;
            }

            // Actuators
            thrust_forward(a) {
                var vfa = game.physics.arcade.velocityFromAngle(this.sprite.angle, a); 
                this.sprite.body.velocity.x += vfa.x
                this.sprite.body.velocity.y += vfa.y
            }

            thrust_left(a) {
                this.sprite.body.angularVelocity -= ((a + 1.0) / 2.0);
                if (this.sprite.body.angularVelocity < (-1.0 * this.MAX_ANGULAR)) { this.sprite.body.angularVelocity = -1.0 * this.MAX_ANGULAR; }
            }

            thrust_right(a) {
                this.sprite.body.angularVelocity += (a + 1.0)/2.0;
                if (this.sprite.body.angularVelocity > this.MAX_ANGULAR) { this.sprite.body.angularVelocity = this.MAX_ANGULAR; }
            }
    
            nonlin(x) {
                for (var i = 0; i < x.shape[0]; i++) {
                    x.set(i, Math.max(0, x.get(i)))
                }
                return x;
            }

            ff(i) {
                var h_1 = nj.sigmoid(i.dot(this.w_1).add(this.b_1))
                var h_2 = nj.sigmoid(h_1.dot(this.w_2).add(this.b_2))
                return nj.sigmoid(h_2.dot(this.w_out).add(this.b_out))
            }

            next(args) {
                var dists = args['distances']
                dists.sort(function(a, b) { return a[0] - b[0] })
                var top_3 = dists.slice(1, 4);
                
                var mx = this.sprite.x
                var my = this.sprite.y
                if (top_3.length >= 3) {
                    var i = nj.array([mx - top_3[0][1].sprite.x, my - top_3[0][1].sprite.y, mx - top_3[1][1].sprite.x, my - top_3[1][1].sprite.y, mx - top_3[2][1].sprite.x, my - top_3[2][1].sprite.y, 0.0, 0.0, 0.0, 0.0])
                }
                else {
                    var i = nj.zeros([10])
                }
                var out = this.ff(i)

                this.thrust_forward(out.get(0) * this.movement_weights[0])
                this.thrust_left(out.get(1) * this.movement_weights[1])
                this.thrust_right(out.get(2) * this.movement_weights[2])

                // World wrap
                /*
                if (this.sprite.x > game.world.width) { this.sprite.x = 50; }
                if (this.sprite.x < 0) { this.sprite.x = game.world.width - 50; }
                if (this.sprite.y > game.world.height) { this.sprite.y = 50; }
                if (this.sprite.y < 0) { this.sprite.y = game.world.height - 50; }
                */
                game.world.wrap(this.sprite, 5.0, false,  true, true)

                // Mav vel
                this.sprite.body.velocity.setMagnitude(Math.min(this.MAX_SPEED, this.sprite.body.velocity.getMagnitude()));

                // No skate
                //this.sprite.angle = Math.atan2(this.sprite.body.velocity.y, this.sprite.body.velocity.x) * (180.0 / Math.PI)
            }
            
        }

        EM = new EnemyManager();
        e0 = new Enemy(32, 16, '#ffffff', game.world.width / 3, game.world.centerY - 30, 0);
        e1 = new Enemy(32, 16, '#ffffff', 2 * (game.world.width / 3), game.world.centerY + 30, 180);
        e2 = new Enemy(32, 16, '#ffffff', game.world.width / 3, game.world.centerY - 90, 0);
        e3 = new Enemy(32, 16, '#ffffff', 2 * (game.world.width / 3), game.world.centerY + 90, 180);
        EM.addEnemy(e0)
        EM.addEnemy(e1)
        EM.addEnemy(e2)
        EM.addEnemy(e3)
       /* //  A simple background for our game
        game.add.sprite(0, 0, 'sky');

        //  The platforms group contains the ground and the 2 ledges we can jump on
        platforms = game.add.group();

        //  We will enable physics for any object that is created in this group
        platforms.enableBody = true;

        // Here we create the ground.
        var ground = platforms.create(0, game.world.height - 64, 'ground');

        //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
        ground.scale.setTo(2, 2);

        //  This stops it from falling away when you jump on it
        ground.body.immovable = true;

        //  Now let's create two ledges
        var ledge = platforms.create(400, 400, 'ground');

        ledge.body.immovable = true;

        ledge = platforms.create(-150, 250, 'ground');

        ledge.body.immovable = true;
       
        // The player and its settings
        player = game.add.sprite(32, game.world.height - 150, 'dude');

        //  We need to enable physics on the player
        game.physics.arcade.enable(player);

        //  Player physics properties. Give the little guy a slight bounce.
        player.body.bounce.y = 0.2;
        player.body.gravity.y = 300;
        player.body.collideWorldBounds = true;

        //  Our two animations, walking left and right.
        player.animations.add('left', [0, 1, 2, 3], 10, true);
        player.animations.add('right', [5, 6, 7, 8], 10, true);

        stars = game.add.group();

        stars.enableBody = true;

        //  Here we'll create 12 of them evenly spaced apart
        for (var i = 0; i < 12; i++)
        {
            //  Create a star inside of the 'stars' group
            var star = stars.create(i * 70, 0, 'star');

            //  Let gravity do its thing
            star.body.gravity.y = 6;

            //  This just gives each star a slightly random bounce value
            star.body.bounce.y = 0.7 + Math.random() * 0.2;
        }
        */
     }

    function update() {
        EM.next()

        /*
        //  Collide the player and the stars with the platforms
        var hitPlatform = game.physics.arcade.collide(player, platforms);

        //  Reset the players velocity (movement)
        player.body.velocity.x = 0;

        if (cursors.left.isDown)
        {
            //  Move to the left
            player.body.velocity.x = -150;

            player.animations.play('left');
        }
        else if (cursors.right.isDown)
        {
            //  Move to the right
            player.body.velocity.x = 150;

            player.animations.play('right');
        }
        else
        {
            //  Stand still
            player.animations.stop();

            player.frame = 4;
        }

        //  Allow the player to jump if they are touching the ground.
        if (cursors.up.isDown && player.body.touching.down && hitPlatform)
        {
            player.body.velocity.y = -350;
        }

        game.physics.arcade.collide(stars, platforms);
        game.physics.arcade.overlap(player, stars, collectStar, null, this);
        */
    }
    
/*
    function collectStar (player, star) {

        // Removes the star from the screen
        star.kill();

    }
*/
</script>

</body>
</html>
